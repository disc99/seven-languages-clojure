(2 * 2)
(2+2)
(-1)
(- 1)
(* 1)
(* 1 1 1)
(* 1 2 3)
(def big [str n] (< str n))
(defn big [str n] (< str n))
(big st n)
(big "aaa" 1)
(defn test [_] (< 1 2))
(defn test [x] (< 1 2))
(test 1)
(defn big [str n] (< (length str) n))
(defn big [str n] (< (size str) n))
(defn big [str n] (< (count str) n))
(big "aaa" 1)
(defn big [str n] (> (count str) n))
(big "aaa" 1)
(big "aaa" 2)
(big "aaa" 3)
(big "aaa" 4)
(big "aaa" -10)
(big "aaa" -1000000000000000000)
(big "aaa" 1000000000000000000)
(defn collection-type col 
(defn collection-type [col] (class col))
(collection-type 1)
(collection-type [1])
(defn collection-type [col] (= class col) clojure.lang.PersistentVector)
(collection-type [1])
(defn collection-type [col] (= (class col) clojure.lang.PersistentVector))
(collection-type [1])
(collection-type 1)
(class ())
(class (1))
(class (1 1))
(class (list 1 1))
(class {})
(defn collection-type [col] (= (class col) PersistentVector))
(defn collection-type [col] ((class col) {clojure.lang.PersistentVector}))
(defn collection-type [col] ((class col) {clojure.lang.PersistentVector :vector}))
(collection-type [1])
(defn fib-pair [[a b] [b (+ a b)])
(defn fib-pair [[a b]] [b (+ a b)])
(fib-piar [3 5])
(fib-pair [3 5])
(take 5
(map
first
(iterate fib-pair [1 1])))
(nth (map first (iterate fib-pair [1 1])) 500)
(nth (map first (iterate fib-pair [1 1])) 50)
(defprotocol Compass
(direction [c])
(left [c])
(right [c]))
(def directions [:north :east :south :west])
(defn turn
[base amount]
(rem (+ base amount) (cuont directions)))
(defn turn [base amount] (rem (+ base amount) (count directions)))
(turn 1 1)
(turn 3 1)
(defrecord SimpleCOmpass [bearing] Compass)
(defrecord SimpleCompass [bearing] Compass)
(direction [_] (directions bearing))
